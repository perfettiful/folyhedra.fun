<!doctype html>
<!-- 
  IMPORTANT: This file uses ES6 modules with external URLs.
  To run properly, serve it through a web server, not file://.
  
  Quick options:
  - Python: python -m http.server 8000
  - Node.js: npx serve .
  - VS Code: Live Server extension
  
  Then visit: http://localhost:8000
-->
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Incomplete Tetrahedra Explorer</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”º</text></svg>" />
<style>
  html, body { margin:0; height:100%; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  #ui {
    position: fixed; top: 12px; left: 12px; z-index: 10;
    background: rgba(20,20,24,0.9); color: #eaeaea; padding: 10px 12px; border-radius: 10px;
    display: grid; gap: 6px; box-shadow: 0 6px 20px rgba(0,0,0,0.35);
  }
  #ui label { font-size: 12px; opacity: .9; }
  #ui select, #ui input[type=checkbox] { margin-top: 4px; }
  #panel {
    position: fixed; right: 12px; top: 12px; z-index: 10;
    width: 320px; max-width: 45vw;
    background: rgba(20,20,24,0.9); color: #eaeaea; padding: 12px 14px; border-radius: 10px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.35);
  }
  #panel h2 { margin: 0 0 8px 0; font-size: 16px; }
  #panel .kv { font-size: 12px; line-height: 1.5; }
  #rating { display: inline-flex; gap: 2px; cursor: pointer; }
  .star { font-size: 18px; color: #666; }
  .star.on { color: #ffd34d; text-shadow: 0 0 6px rgba(255,211,77,0.5); }
  #hint {
    position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); z-index: 9;
    color:#ddd; background: rgba(0,0,0,0.5); padding:6px 10px; border-radius: 8px; font-size: 12px;
  }
  a { color:#9bd; }
</style>
</head>
<body>
<div id="ui">
  <div>
    <label>Filter:</label><br/>
    <select id="filter">
      <option value="connected_noface" selected>Connected + No Full Face (valid)</option>
      <option value="connected">Connected</option>
      <option value="all">All non-empty (no full)</option>
    </select>
  </div>
  <div>
    <label><input type="checkbox" id="uniq" checked> Rotation-unique</label>
  </div>
  <div>
    <label>Edge style:</label><br/>
    <select id="style">
      <option value="solid" selected>Solid</option>
      <option value="wire">Wireframe</option>
    </select>
  </div>
  <div>
    <label>Background:</label><br/>
    <select id="background">
      <option value="gray-gradient" selected>Gray Gradient</option>
      <option value="white">White</option>
      <option value="black">Black</option>
      <option value="blue">Blue</option>
      <option value="green">Green</option>
      <option value="purple">Purple</option>
      <option value="night-sky">Night Sky</option>
      <option value="meadow">Meadow</option>
      <option value="beach">Beach</option>
      <option value="forest">Forest</option>
      <option value="sunset">Sunset</option>
      <option value="ocean">Ocean</option>
    </select>
  </div>
  <div>
    <label>Platform height:</label><br/>
    <input type="range" id="platformHeight" min="-1" max="1" step="0.05" value="-0.8" style="width: 100%;"/>
    <div style="font-size: 10px; opacity: 0.8; margin-top: 2px;" id="platformValue">-0.1</div>
  </div>
</div>

<div id="panel">
  <h2 id="title">Select a figure</h2>
  <div class="kv" id="info">
    Click a tetra to see details.
  </div>
  <div style="margin-top:8px;">
    <span style="font-size:12px; opacity:.9;">Rate:</span>
    <span id="rating"></span>
  </div>
  <div style="margin-top:10px; font-size:11px; opacity:.75;">
    Controls: drag to orbit Â· wheel to zoom Â· right-drag to pan Â· drag a shape to move it.<br/>
    Three.js <a href="https://threejs.org/" target="_blank" rel="noreferrer">docs</a>
  </div>
</div>

<div id="hint">Tip: toggle "Rotation-unique" to see canonical reps vs. all variants.</div>

<div id="loading" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);font-family:Arial;font-size:18px;color:#333;background:rgba(255,255,255,0.9);padding:20px;border-radius:10px;box-shadow:0 4px 20px rgba(0,0,0,0.1);">
  Loading 3D Scene...
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>
<script type="module">
/* ===== Imports (using jsDelivr CDN) ===== */
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { DragControls } from 'three/addons/controls/DragControls.js';

/* ===== DOM elements ===== */
const filterSel = document.getElementById('filter');
const uniqChk = document.getElementById('uniq');
const styleSel = document.getElementById('style');
const backgroundSel = document.getElementById('background');
const platformHeightSlider = document.getElementById('platformHeight');
const platformValueDisplay = document.getElementById('platformValue');
const panelTitle = document.getElementById('title');
const panelInfo = document.getElementById('info');
const ratingEl = document.getElementById('rating');

/* ===== Scene setup ===== */
const scene = new THREE.Scene();

/* ===== Background System ===== */
function createSolidBackground(color) {
  return new THREE.Color(color);
}

function applyTextureSettings(texture) {
  texture.wrapS = THREE.ClampToEdgeWrapping;
  texture.wrapT = THREE.ClampToEdgeWrapping;
  texture.magFilter = THREE.LinearFilter;
  texture.minFilter = THREE.LinearFilter;
  return texture;
}

function createGradientBackground(color1, color2, direction = 'vertical') {
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 1024;
  const ctx = canvas.getContext('2d');
  
  let gradient;
  if (direction === 'vertical') {
    gradient = ctx.createLinearGradient(0, 0, 0, 1024);
  } else {
    gradient = ctx.createLinearGradient(0, 0, 1024, 0);
  }
  
  gradient.addColorStop(0, color1);
  gradient.addColorStop(1, color2);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 1024, 1024);
  
  return applyTextureSettings(new THREE.CanvasTexture(canvas));
}

function createNightSkyBackground() {
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 1024;
  const ctx = canvas.getContext('2d');
  
  // Night sky gradient
  const gradient = ctx.createLinearGradient(0, 0, 0, 1024);
  gradient.addColorStop(0, '#0a0a2e');
  gradient.addColorStop(0.7, '#16213e');
  gradient.addColorStop(1, '#0f3460');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 1024, 1024);
  
  // Add stars
  ctx.fillStyle = '#ffffff';
  for (let i = 0; i < 400; i++) {
    const x = Math.random() * 1024;
    const y = Math.random() * 1024;
    const size = Math.random() * 2;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Add some brighter stars
  ctx.fillStyle = '#ffff88';
  for (let i = 0; i < 40; i++) {
    const x = Math.random() * 1024;
    const y = Math.random() * 1024;
    const size = Math.random() * 3 + 1;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }
  
  return applyTextureSettings(new THREE.CanvasTexture(canvas));
}

function createMeadowBackground() {
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 1024;
  const ctx = canvas.getContext('2d');
  
  // Sky gradient
  const skyGradient = ctx.createLinearGradient(0, 0, 0, 600);
  skyGradient.addColorStop(0, '#87CEEB');
  skyGradient.addColorStop(1, '#98FB98');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, 1024, 600);
  
  // Grass
  const grassGradient = ctx.createLinearGradient(0, 600, 0, 1024);
  grassGradient.addColorStop(0, '#90EE90');
  grassGradient.addColorStop(1, '#228B22');
  ctx.fillStyle = grassGradient;
  ctx.fillRect(0, 600, 1024, 424);
  
  // Add some flowers
  for (let i = 0; i < 60; i++) {
    const x = Math.random() * 1024;
    const y = 600 + Math.random() * 300;
    ctx.fillStyle = ['#FF69B4', '#FFB6C1', '#FFA500', '#FFFF00'][Math.floor(Math.random() * 4)];
    ctx.beginPath();
    ctx.arc(x, y, Math.random() * 4 + 2, 0, Math.PI * 2);
    ctx.fill();
  }
  
  return new THREE.CanvasTexture(canvas);
}

function createBeachBackground() {
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 1024;
  const ctx = canvas.getContext('2d');
  
  // Sky
  const skyGradient = ctx.createLinearGradient(0, 0, 0, 400);
  skyGradient.addColorStop(0, '#87CEEB');
  skyGradient.addColorStop(1, '#E0F6FF');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, 1024, 400);
  
  // Ocean
  const oceanGradient = ctx.createLinearGradient(0, 400, 0, 700);
  oceanGradient.addColorStop(0, '#4682B4');
  oceanGradient.addColorStop(1, '#1E90FF');
  ctx.fillStyle = oceanGradient;
  ctx.fillRect(0, 400, 1024, 300);
  
  // Sand
  const sandGradient = ctx.createLinearGradient(0, 700, 0, 1024);
  sandGradient.addColorStop(0, '#F4A460');
  sandGradient.addColorStop(1, '#D2B48C');
  ctx.fillStyle = sandGradient;
  ctx.fillRect(0, 700, 1024, 324);
  
  // Add some waves
  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = 2;
  for (let i = 0; i < 5; i++) {
    ctx.beginPath();
    ctx.moveTo(0, 440 + i * 40);
    for (let x = 0; x < 1024; x += 40) {
      ctx.lineTo(x, 440 + i * 40 + Math.sin(x * 0.1) * 6);
    }
    ctx.stroke();
  }
  
  return new THREE.CanvasTexture(canvas);
}

function createForestBackground() {
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 1024;
  const ctx = canvas.getContext('2d');
  
  // Sky
  const skyGradient = ctx.createLinearGradient(0, 0, 0, 400);
  skyGradient.addColorStop(0, '#87CEEB');
  skyGradient.addColorStop(1, '#228B22');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, 1024, 400);
  
  // Trees silhouette
  ctx.fillStyle = '#006400';
  for (let i = 0; i < 40; i++) {
    const x = (i / 40) * 1024;
    const height = 300 + Math.random() * 200;
    const width = 40 + Math.random() * 60;
    ctx.fillRect(x, 400, width, height);
    
    // Tree tops
    ctx.beginPath();
    ctx.arc(x + width/2, 400, width/2, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Ground
  ctx.fillStyle = '#2F4F2F';
  ctx.fillRect(0, 800, 1024, 224);
  
  return new THREE.CanvasTexture(canvas);
}

function createSunsetBackground() {
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 1024;
  const ctx = canvas.getContext('2d');
  
  // Sunset gradient
  const gradient = ctx.createLinearGradient(0, 0, 0, 1024);
  gradient.addColorStop(0, '#FF4500');
  gradient.addColorStop(0.3, '#FF6347');
  gradient.addColorStop(0.6, '#FFD700');
  gradient.addColorStop(0.8, '#FF69B4');
  gradient.addColorStop(1, '#8B008B');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 1024, 1024);
  
  // Sun
  ctx.fillStyle = '#FFFF00';
  ctx.beginPath();
  ctx.arc(800, 300, 100, 0, Math.PI * 2);
  ctx.fill();
  
  // Sun glow
  const sunGlow = ctx.createRadialGradient(800, 300, 100, 800, 300, 200);
  sunGlow.addColorStop(0, 'rgba(255,255,0,0.3)');
  sunGlow.addColorStop(1, 'rgba(255,255,0,0)');
  ctx.fillStyle = sunGlow;
  ctx.beginPath();
  ctx.arc(800, 300, 200, 0, Math.PI * 2);
  ctx.fill();
  
  return new THREE.CanvasTexture(canvas);
}

function createOceanBackground() {
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 1024;
  const ctx = canvas.getContext('2d');
  
  // Ocean gradient
  const gradient = ctx.createLinearGradient(0, 0, 0, 1024);
  gradient.addColorStop(0, '#87CEEB');
  gradient.addColorStop(0.3, '#4682B4');
  gradient.addColorStop(0.7, '#1E90FF');
  gradient.addColorStop(1, '#000080');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 1024, 1024);
  
  // Add wave patterns
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 2;
  for (let y = 200; y < 1000; y += 80) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    for (let x = 0; x < 1024; x += 40) {
      ctx.lineTo(x, y + Math.sin(x * 0.05 + y * 0.01) * 16);
    }
    ctx.stroke();
  }
  
  return new THREE.CanvasTexture(canvas);
}

function setBackground(type) {
  let background;
  
  switch(type) {
    case 'white':
      background = createSolidBackground('#ffffff');
      break;
    case 'black':
      background = createSolidBackground('#000000');
      break;
    case 'blue':
      background = createSolidBackground('#4682B4');
      break;
    case 'green':
      background = createSolidBackground('#228B22');
      break;
    case 'purple':
      background = createSolidBackground('#8B008B');
      break;
    case 'night-sky':
      background = createNightSkyBackground();
      break;
    case 'meadow':
      background = createMeadowBackground();
      break;
    case 'beach':
      background = createBeachBackground();
      break;
    case 'forest':
      background = createForestBackground();
      break;
    case 'sunset':
      background = createSunsetBackground();
      break;
    case 'ocean':
      background = createOceanBackground();
      break;
    case 'gray-gradient':
    default:
      background = createGradientBackground('#f5f5f5', '#888888');
      break;
  }
  
  scene.background = background;
}

// Set initial background
setBackground('gray-gradient');

/* ===== Platform Height Control ===== */
function updatePlatformHeight(topSurfaceHeight) {
  // Position table so its TOP surface is at the specified height
  // Table height is 0.2, so center should be 0.1 below the top surface
  table.position.y = topSurfaceHeight - 0.1;
  grid.position.y = topSurfaceHeight + 0.01; // Grid slightly above top surface
  platformValueDisplay.textContent = topSurfaceHeight.toFixed(2);
}

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 200);
camera.position.set(4.5, 4.0, 7.0);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.minDistance = 2.0;
controls.maxDistance = 30.0;
controls.target.set(0, 0.6, 0);
controls.update();

/* Lights */
const hemi = new THREE.HemisphereLight(0xffffff, 0x666666, 0.8);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(5, 8, 4);
dir.castShadow = true;
dir.shadow.mapSize.set(2048, 2048);
scene.add(dir);

/* Table */
const table = new THREE.Mesh(
  new THREE.BoxGeometry(20, 0.2, 12),
  new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.9, metalness: 0.0 })
);
table.position.y = -0.2; // Will be updated by updatePlatformHeight()
table.receiveShadow = true;
scene.add(table);

/* Subtle grid */
const grid = new THREE.GridHelper(20, 20, 0x777777, 0x666666);
grid.position.y = -0.09; // Will be updated by updatePlatformHeight()
scene.add(grid);

/* ===== Tetrahedron combinatorics =====
   Vertices chosen as a regular tetra centered ~origin (scaled)
*/
const V = [
  new THREE.Vector3( 1,  1,  1),
  new THREE.Vector3( 1, -1, -1),
  new THREE.Vector3(-1,  1, -1),
  new THREE.Vector3(-1, -1,  1),
].map(v => v.multiplyScalar(0.6)); // scale

// Edges: (01),(02),(03),(12),(13),(23)
const E = [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]];
const E_INDEX = new Map(E.map((e,i)=>[e.join(','), i]));

// Faces (omit one vertex each)
const FACES = [];
for (let miss = 0; miss < 4; miss++) {
  const vs = [0,1,2,3].filter(v => v !== miss);
  const es = [];
  for (let i=0;i<vs.length;i++) for (let j=i+1;j<vs.length;j++){
    const a = Math.min(vs[i],vs[j]), b = Math.max(vs[i],vs[j]);
    es.push(E_INDEX.get(`${a},${b}`));
  }
  FACES.push(new Set(es)); // size 3
}

// Adjacency (for connectivity)
const ADJ = Array.from({length:4}, ()=>[]);
E.forEach(([a,b], ei)=>{
  ADJ[a].push([b, ei]);
  ADJ[b].push([a, ei]);
});

/* ===== A4 rotations as even permutations on vertices -> edge perms ===== */
function isEvenPerm(p) {
  let inv=0;
  for(let i=0;i<4;i++) for(let j=i+1;j<4;j++) if (p[i]>p[j]) inv++;
  return (inv % 2) === 0;
}
const A4 = [];
for (const p of permute([0,1,2,3])) if (isEvenPerm(p)) A4.push(p);

function permute(arr){
  if (arr.length===0) return [[]];
  const out=[];
  function rec(a, m=[]){
    if (a.length===0) out.push(m);
    else for(let i=0;i<a.length;i++){
      const aa=a.slice(), x=aa.splice(i,1);
      rec(aa, m.concat(x));
    }
  }
  rec(arr.slice());
  return out;
}

function edgePermFromVertexPerm(p){
  const m = new Array(6);
  for (let ei=0; ei<6; ei++){
    let [a,b] = E[ei];
    const a2 = p[a], b2 = p[b];
    const u = Math.min(a2,b2), v = Math.max(a2,b2);
    m[ei] = E_INDEX.get(`${u},${v}`);
  }
  return m;
}
const ROT_EDGE_PERMS = [...new Set(A4.map(p => edgePermFromVertexPerm(p).join(',')))]
  .map(s => s.split(',').map(Number)); // 12

/* ===== Bitmask helpers ===== */
function rotateMask(mask, perm){
  let out=0;
  for(let i=0;i<6;i++){
    if ((mask>>i)&1) out |= (1<<perm[i]);
  }
  return out;
}
function canonical(mask){
  let min = Infinity;
  for (const p of ROT_EDGE_PERMS){
    const m = rotateMask(mask, p);
    if (m < min) min = m;
  }
  return min;
}
function isConnected(mask){
  const used = new Set();
  for (let ei=0; ei<6; ei++){
    if ((mask>>ei)&1){
      used.add(E[ei][0]); used.add(E[ei][1]);
    }
  }
  if (used.size===0) return false;
  const arr=[...used];
  const q=[arr[0]];
  const seen=new Set([arr[0]]);
  while(q.length){
    const u=q.shift();
    for (const [v, ei] of ADJ[u]){
      if (((mask>>ei)&1) && !seen.has(v)){
        seen.add(v); q.push(v);
      }
    }
  }
  return seen.size===used.size;
}
function hasFullFace(mask){
  for (const f of FACES){
    let ok=true;
    for (const e of f){
      if (!((mask>>e)&1)) { ok=false; break; }
    }
    if (ok) return true;
  }
  return false;
}

/* ===== Generate masks per UI ===== */
function generateMasks(mode, rotationUnique){
  const full = (1<<6)-1;
  const raw = [];
  for (let m=1; m<full; m++){ // exclude empty and full
    if (mode==='connected' || mode==='connected_noface'){
      if (!isConnected(m)) continue;
    }
    if (mode==='connected_noface'){
      if (hasFullFace(m)) continue;
    }
    raw.push(m);
  }
  if (!rotationUnique) return raw;

  const reps = new Set();
  for (const m of raw) reps.add(canonical(m));
  return [...reps];
}

/* ===== 3D building blocks ===== */
const objects = []; // draggable
const groupRoot = new THREE.Group(); scene.add(groupRoot);

const matEdge = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.3 });
const matEdgeWire = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.0, roughness: 0.8, wireframe:true });
const matGhost = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.0, roughness: 1.0, transparent:true, opacity: 0.15 });

function cylinderBetween(a, b, radius=0.05){
  const dir = new THREE.Vector3().subVectors(b,a);
  const len = dir.length();
  const geom = new THREE.CylinderGeometry(radius, radius, len, 16, 1, false);
  const mesh = new THREE.Mesh(geom, matEdge);
  mesh.castShadow = true;
  // orient Y-axis to dir
  const mid = new THREE.Vector3().addVectors(a,b).multiplyScalar(0.5);
  mesh.position.copy(mid);
  const up = new THREE.Vector3(0,1,0);
  const quat = new THREE.Quaternion().setFromUnitVectors(up, dir.clone().normalize());
  mesh.quaternion.copy(quat);
  return mesh;
}

function tetraGroupFromMask(mask, edgeStyle='solid'){
  const g = new THREE.Group();
  // faint full frame (ghost)
  for (let ei=0; ei<6; ei++){
    const [i,j] = E[ei];
    const cyl = cylinderBetween(V[i], V[j], 0.02);
    cyl.material = matGhost;
    // Completely disable raycasting for individual parts
    cyl.raycast = () => {};
    g.add(cyl);
  }
  // selected edges
  for (let ei=0; ei<6; ei++){
    if ((mask>>ei)&1){
      const [i,j] = E[ei];
      const cyl = cylinderBetween(V[i], V[j], 0.05);
      cyl.material = (edgeStyle==='wire' ? matEdgeWire : matEdge);
      // Completely disable raycasting for individual parts
      cyl.raycast = () => {};
      g.add(cyl);
    }
  }
  // small vertex spheres for selected vertices
  const usedV = new Set();
  for (let ei=0; ei<6; ei++) if ((mask>>ei)&1){ usedV.add(E[ei][0]); usedV.add(E[ei][1]); }
  for (const vi of usedV){
    const s = new THREE.Mesh(new THREE.SphereGeometry(0.06, 16, 12),
      new THREE.MeshStandardMaterial({ color: 0xffffff, metalness:0.1, roughness:0.35 }));
    s.position.copy(V[vi]);
    s.castShadow = true;
    // Completely disable raycasting for individual parts
    s.raycast = () => {};
    g.add(s);
  }
  
  // Rotate tetrahedron so one face lies flat on the XZ plane with point facing UP
  // Use vertex 0 as the top point, and face made of vertices 1,2,3 as the base
  // Calculate rotation to make face normal point DOWN so face sits on ground
  const v1 = V[1], v2 = V[2], v3 = V[3];
  const edge1 = new THREE.Vector3().subVectors(v2, v1);
  const edge2 = new THREE.Vector3().subVectors(v3, v1);
  const faceNormal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
  
  // We want this face normal to point DOWN (-Y) so the face sits on the ground
  // and vertex 0 (the opposite point) faces UP like a pyramid
  const targetNormal = new THREE.Vector3(0, -1, 0);
  const rotationAxis = new THREE.Vector3().crossVectors(faceNormal, targetNormal).normalize();
  const rotationAngle = Math.acos(Math.max(-1, Math.min(1, faceNormal.dot(targetNormal))));
  
  if (rotationAxis.length() > 0.001) { // Only rotate if not already aligned
    g.rotateOnAxis(rotationAxis, rotationAngle);
  }
  
  g.userData.mask = mask;
  g.userData.canonical = canonical(mask);
  g.userData.orbitSize = new Set(ROT_EDGE_PERMS.map(p => rotateMask(mask,p))).size;
  g.userData.edgeCount = countBits(mask);
  g.userData.degrees = vertexDegrees(mask);
  g.userData.connected = isConnected(mask);
  g.userData.hasFace = hasFullFace(mask);
  g.userData.rating = getRating(g.userData.canonical);
  return g;
}

function countBits(m){ let c=0; while(m){ c+=m&1; m>>=1; } return c; }
function vertexDegrees(mask){
  const deg = [0,0,0,0];
  for (let ei=0; ei<6; ei++){
    if ((mask>>ei)&1){
      const [a,b] = E[ei];
      deg[a]++; deg[b]++;
    }
  }
  return deg.sort((a,b)=>b-a); // multiset, descending
}

/* ===== Layout & rebuild ===== */
function clearObjects(){
  for (const o of objects){
    groupRoot.remove(o);
    o.traverse(n=>{ if (n.geometry) n.geometry.dispose(); if (n.material?.dispose) n.material.dispose(); });
  }
  objects.length = 0;
}

function rebuild(){
  clearObjects();
  const mode = filterSel.value;
  const rotationUnique = uniqChk.checked;
  const style = styleSel.value;

  const masks = generateMasks(mode, rotationUnique);
  // grid layout
  const n = masks.length;
  const cols = Math.ceil(Math.sqrt(n));
  const spacing = 2.5;
  const origin = new THREE.Vector3(-(cols-1)*spacing*0.5, 0.01, -Math.ceil(n/cols)*spacing*0.5);
  for (let idx=0; idx<n; idx++){
    const g = tetraGroupFromMask(masks[idx], style);
    const r = Math.floor(idx/cols);
    const c = idx % cols;
    g.position.copy(origin).add(new THREE.Vector3(c*spacing, 0.0, r*spacing));
    g.position.y = 0.3; // sit properly above platform
    g.userData.idx = idx;
    g.userData.label = labelFor(g.userData);
    groupRoot.add(g);
    objects.push(g);
  }
  // refresh drag controls with new objects
  initializeDragControls();
  // clear selection
  setSelection(null);
}

/* ===== Selection, raycasting, panel ===== */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let selection = null;

function setSelection(obj){
  selection = obj;
  if (!obj){
    panelTitle.textContent = 'Select a figure';
    panelInfo.innerHTML = 'Click a tetra to see details.';
    renderStars(null);
    return;
  }
  const ud = obj.userData;
  panelTitle.textContent = `Figure #${ud.idx+1}`;
  const bits = (ud.mask >>> 0).toString(2).padStart(6,'0');
  const hex  = '0x' + (ud.mask >>> 0).toString(16).toUpperCase().padStart(2,'0');
  panelInfo.innerHTML = `
    <div class="kv">
      <b>Mask:</b> ${ud.mask} (${hex}, bits ${bits})<br/>
      <b>Edges:</b> ${ud.edgeCount} &nbsp; <b>Degrees:</b> [${ud.degrees.join(', ')}]<br/>
      <b>Connected:</b> ${ud.connected ? 'Yes' : 'No'} &nbsp; <b>Full face:</b> ${ud.hasFace ? 'Yes' : 'No'}<br/>
      <b>Canonical:</b> ${ud.canonical} &nbsp; <b>Orbit size:</b> ${ud.orbitSize}<br/>
      <b>Label:</b> ${ud.label}
    </div>`;
  renderStars(ud.canonical);
}

function onClick(ev){
  // ignore clicks when dragging
  if (dragging) return;
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(objects, true);
  if (intersects.length){
    // climb to top-level group
    let obj = intersects[0].object;
    while (obj && !objects.includes(obj)) obj = obj.parent;
    setSelection(obj || null);
  }
}
renderer.domElement.addEventListener('pointerdown', onClick);

/* ===== Drag controls ===== */
let dragging = false;
let dragControls;

function initializeDragControls() {
  if (dragControls) {
    dragControls.dispose();
  }
  
  // Use the group objects directly for dragging (simpler approach)
  dragControls = new DragControls(objects, camera, renderer.domElement);
  
  dragControls.addEventListener('dragstart', (e) => { 
    dragging = true; 
    controls.enabled = false;
  });

  dragControls.addEventListener('dragend', (e) => {
    dragging = false; 
    controls.enabled = true;
    // constrain Y to hover above table
    const obj = e.object;
    obj.position.y = Math.max(obj.position.y, 0.3);
  });
}

/* ===== Rating (localStorage) ===== */
function storageKey(can){ return `tetra-rating:${can}`; }
function getRating(can){
  if (can==null) return 0;
  const v = localStorage.getItem(storageKey(can));
  return v ? parseInt(v,10) : 0;
}
function setRating(can, r){
  localStorage.setItem(storageKey(can), String(r));
  // update any object sharing this canonical
  for (const o of objects){
    if (o.userData.canonical === can){
      o.userData.rating = r;
    }
  }
  renderStars(can);
}
function renderStars(canonical){
  ratingEl.innerHTML = '';
  for (let i=1;i<=5;i++){
    const s = document.createElement('span');
    s.className = 'star';
    s.textContent = 'â˜…';
    if (canonical && getRating(canonical) >= i) s.classList.add('on');
    s.addEventListener('click', ()=> canonical && setRating(canonical, i));
    ratingEl.appendChild(s);
  }
}

/* ===== Labels (simple classifier) ===== */
function labelFor(ud){
  const d = ud.degrees.join(',');
  const k = ud.edgeCount;
  if (k===1) return 'Kâ‚‚ (single edge)';
  if (k===2){
    // connected only case is P3
    return 'Pâ‚ƒ (two adjacent edges)';
  }
  if (k===3){
    if (d==='3,1,1,1') return 'Kâ‚,â‚ƒ (star)';
    if (ud.hasFace) return 'Triangle (face)';
    if (d==='2,2,1,1') return 'Pâ‚„ (3-edge path)';
    return 'Other 3-edge';
  }
  if (k===4){
    if (!ud.hasFace && d==='2,2,2,2') return 'Câ‚„ (4-cycle)';
    if (ud.hasFace) return 'Triangle + edge';
  }
  if (k===5) return 'Kâ‚„âˆ’e (contains faces)';
  return `Edges=${k}`;
}

/* ===== UI wiring ===== */
filterSel.addEventListener('change', rebuild);
uniqChk.addEventListener('change', rebuild);
styleSel.addEventListener('change', rebuild);
backgroundSel.addEventListener('change', (e) => {
  setBackground(e.target.value);
});
platformHeightSlider.addEventListener('input', (e) => {
  updatePlatformHeight(parseFloat(e.target.value));
});

/* ===== Resize & animate ===== */
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
function tick(){
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}

/* ===== Initial populate ===== */
// Hide loading indicator
document.getElementById('loading').style.display = 'none';

// Set initial platform height
updatePlatformHeight(-0.8);

rebuild();
tick();
</script>
</body>
</html>
